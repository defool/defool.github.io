<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>七叶的博客</title>
    <link>http://sample.com</link>
    <pubDate>28 Aug 16 14:25 CST</pubDate>
    <item>
      <title>Python性能优化的20条建议</title>
      <link>http://sample.com/性能优化/Python%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%8420%E6%9D%A1%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>2014-09-12 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;&#xA;&lt;li&gt;&lt;h3&gt;优化算法时间复杂度&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;算法的时间复杂度对程序的执行效率影响最大，在Python中可以通过选择合适的数据结构来优化时间复杂度，如list和set查找某一个元素的时间复杂度分别是O(n)和O(1)。不同的场景有不同的优化方式，总得来说，一般有分治，分支界限，贪心，动态规划等思想。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;减少冗余数据&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如用上三角或下三角的方式去保存一个大的对称矩阵。在0元素占大多数的矩阵里使用稀疏矩阵表示。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;合理使用copy与deepcopy&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;对于dict和list等数据结构的对象，直接赋值使用的是引用的方式。而有些情况下需要复制整个对象，这时可以使用copy包里的copy和deepcopy，这两个函数的不同之处在于后者是递归复制的。效率也不一样：（以下程序在ipython中运行）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import copy&#xA;a = range(100000)&#xA;%timeit -n 10 copy.copy(a) # 运行10次 copy.copy(a)&#xA;%timeit -n 10 copy.deepcopy(a)&#xA;10 loops, best of 3: 1.55 ms per loop&#xA;10 loops, best of 3: 151 ms per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;timeit后面的-n表示运行的次数，后两行对应的是两个timeit的输出，下同。由此可见后者慢一个数量级。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;h3&gt;使用dict或set查找元素&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;python dict和set都是使用hash表来实现(类似c++11标准库中unordered_map)，查找元素的时间复杂度是O(1)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a = range(1000)&#xA;s = set(a)&#xA;d = dict((i,1) for i in a)&#xA;%timeit -n 10000 100 in d&#xA;%timeit -n 10000 100 in s&#xA;10000 loops, best of 3: 43.5 ns per loop&#xA;10000 loops, best of 3: 49.6 ns per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;dict&lt;/code&gt;的效率略高(占用的空间也多一些)。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;合理使用生成器（generator）和yield&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;%timeit -n 100 a = (i for i in range(100000))&#xA;%timeit -n 100 b = [i for i in range(100000)]&#xA;100 loops, best of 3: 1.54 ms per loop&#xA;100 loops, best of 3: 4.56 ms per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用&lt;code&gt;()&lt;/code&gt;得到的是一个generator对象，所需要的内存空间与列表的大小无关，所以效率会高一些。在具体应用上，比如set(i for i in range(100000))会比set([i for i in range(100000)])快。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是对于需要循环遍历的情况：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;%timeit -n 10 for x in (i for i in range(100000)): pass&#xA;%timeit -n 10 for x in [i for i in range(100000)]: pass&#xA;10 loops, best of 3: 6.51 ms per loop&#xA;10 loops, best of 3: 5.54 ms per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;后者的效率反而更高，但是如果循环里有break,用generator的好处是显而易见的。&lt;code&gt;yield&lt;/code&gt;也是用于创建generator：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def yield_func(ls):&#xA;    for i in ls:&#xA;        yield i+1&#xA;&#xA;def not_yield_func(ls):&#xA;    return [i+1 for i in ls]&#xA;&#xA;ls = range(1000000)&#xA;%timeit -n 10 for i in yield_func(ls):pass&#xA;%timeit -n 10 for i in not_yield_func(ls):pass&#xA;10 loops, best of 3: 63.8 ms per loop&#xA;10 loops, best of 3: 62.9 ms per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;对于内存不是非常大的list，可以直接返回一个list，但是可读性&lt;code&gt;yield&lt;/code&gt;更佳(人个喜好)。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;python2.x内置generator功能的有xrange函数、itertools包等。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;优化循环&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;循环之外能做的事不要放在循环内，比如下面的优化可以快一倍：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a = range(10000)&#xA;size_a = len(a)&#xA;%timeit -n 1000 for i in a: k = len(a)&#xA;%timeit -n 1000 for i in a: k = size_a&#xA;1000 loops, best of 3: 569 µs per loop&#xA;1000 loops, best of 3: 256 µs per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;优化包含多个判断表达式的顺序&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;对于and，应该把满足条件少的放在前面，对于or，把满足条件多的放在前面。如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a = range(2000)  &#xA;%timeit -n 100 [i for i in a if 10 &amp;lt; i &amp;lt; 20 or 1000 &amp;lt; i &amp;lt; 2000]&#xA;%timeit -n 100 [i for i in a if 1000 &amp;lt; i &amp;lt; 2000 or 100 &amp;lt; i &amp;lt; 20]     &#xA;%timeit -n 100 [i for i in a if i % 2 == 0 and i &amp;gt; 1900]&#xA;%timeit -n 100 [i for i in a if i &amp;gt; 1900 and i % 2 == 0]&#xA;100 loops, best of 3: 287 µs per loop&#xA;100 loops, best of 3: 214 µs per loop&#xA;100 loops, best of 3: 128 µs per loop&#xA;100 loops, best of 3: 56.1 µs per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;使用join合并迭代器中的字符串&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;In [1]: %%timeit&#xA;   ...: s = &#39;&#39;&#xA;   ...: for i in a:&#xA;   ...:         s += i&#xA;   ...:&#xA;10000 loops, best of 3: 59.8 µs per loop&#xA;&#xA;In [2]: %%timeit&#xA;s = &#39;&#39;.join(a)&#xA;   ...:&#xA;100000 loops, best of 3: 11.8 µs per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;join&lt;/code&gt;对于累加的方式，有大约5倍的提升。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;选择合适的格式化字符方式&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;s1, s2 = &#39;ax&#39;, &#39;bx&#39;&#xA;%timeit -n 100000 &#39;abc%s%s&#39; % (s1, s2)&#xA;%timeit -n 100000 &#39;abc{0}{1}&#39;.format(s1, s2)&#xA;%timeit -n 100000 &#39;abc&#39; + s1 + s2&#xA;100000 loops, best of 3: 183 ns per loop&#xA;100000 loops, best of 3: 169 ns per loop&#xA;100000 loops, best of 3: 103 ns per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;三种情况中，&lt;code&gt;%&lt;/code&gt;的方式是最慢的，但是三者的差距并不大（都非常快）。(个人觉得&lt;code&gt;%&lt;/code&gt;的可读性最好)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;不借助中间变量交换两个变量的值&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;In [3]: %%timeit -n 10000&#xA;    a,b=1,2&#xA;   ....: c=a;a=b;b=c;&#xA;   ....:&#xA;10000 loops, best of 3: 172 ns per loop&#xA;&#xA;In [4]: %%timeit -n 10000&#xA;a,b=1,2&#xA;a,b=b,a&#xA;   ....:&#xA;10000 loops, best of 3: 86 ns per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用&lt;code&gt;a,b=b,a&lt;/code&gt;而不是&lt;code&gt;c=a;a=b;b=c;&lt;/code&gt;来交换a,b的值，可以快1倍以上。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;使用&lt;code&gt;if is&lt;/code&gt;&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a = range(10000)&#xA;%timeit -n 100 [i for i in a if i == True]&#xA;%timeit -n 100 [i for i in a if i is True]&#xA;100 loops, best of 3: 531 µs per loop&#xA;100 loops, best of 3: 362 µs per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;if is True&lt;/code&gt; 比 &lt;code&gt;if == True&lt;/code&gt; 将近快一倍。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;使用级联比较&lt;code&gt;x &amp;lt; y &amp;lt; z&lt;/code&gt;&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;x, y, z = 1,2,3&#xA;%timeit -n 1000000 if x &amp;lt; y &amp;lt; z:pass&#xA;%timeit -n 1000000 if x &amp;lt; y and y &amp;lt; z:pass&#xA;1000000 loops, best of 3: 101 ns per loop&#xA;1000000 loops, best of 3: 121 ns per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;x &amp;lt; y &amp;lt; z&lt;/code&gt;效率略高，而且可读性更好。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;&lt;code&gt;while 1&lt;/code&gt; 比 &lt;code&gt;while True&lt;/code&gt; 更快&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def while_1():&#xA;    n = 100000&#xA;    while 1:&#xA;        n -= 1&#xA;        if n &amp;lt;= 0: break&#xA;def while_true():&#xA;    n = 100000&#xA;    while True:&#xA;        n -= 1&#xA;        if n &amp;lt;= 0: break    &#xA;&#xA;m, n = 1000000, 1000000 &#xA;%timeit -n 100 while_1()&#xA;%timeit -n 100 while_true()&#xA;100 loops, best of 3: 3.69 ms per loop&#xA;100 loops, best of 3: 5.61 ms per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;while 1 比 while true快很多，原因是在python2.x中，True是一个全局变量，而非关键字。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;使用&lt;code&gt;**&lt;/code&gt;而不是pow&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;%timeit -n 10000 c = pow(2,20)&#xA;%timeit -n 10000 c = 2**20&#xA;10000 loops, best of 3: 284 ns per loop&#xA;10000 loops, best of 3: 16.9 ns per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;**&lt;/code&gt;就是快10倍以上！&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;使用 cProfile, cStringIO 和 cPickle等用c实现相同功能（分别对应profile, StringIO, pickle）的包&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import cPickle&#xA;import pickle&#xA;a = range(10000)&#xA;%timeit -n 100 x = cPickle.dumps(a)&#xA;%timeit -n 100 x = pickle.dumps(a)&#xA;100 loops, best of 3: 1.58 ms per loop&#xA;100 loops, best of 3: 17 ms per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;由c实现的包，速度快10倍以上！&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;使用最佳的反序列化方式&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;下面比较了eval, cPickle, json方式三种对相应字符串反序列化的效率：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import json&#xA;import cPickle&#xA;a = range(10000)&#xA;s1 = str(a)&#xA;s2 = cPickle.dumps(a)&#xA;s3 = json.dumps(a)&#xA;%timeit -n 100 x = eval(s1)&#xA;%timeit -n 100 x = cPickle.loads(s2)&#xA;%timeit -n 100 x = json.loads(s3)&#xA;100 loops, best of 3: 16.8 ms per loop&#xA;100 loops, best of 3: 2.02 ms per loop&#xA;100 loops, best of 3: 798 µs per loop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可见json比cPickle快近3倍，比eval快20多倍。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;使用C扩展(Extension)&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;目前主要有CPython(python最常见的实现的方式)原生API, ctypes,Cython，cffi三种方式，它们的作用是使得Python程序可以调用由C编译成的动态链接库，其特点分别是：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;CPython原生API&lt;/strong&gt;: 通过引入&lt;code&gt;Python.h&lt;/code&gt;头文件，对应的C程序中可以直接使用Python的数据结构。实现过程相对繁琐，但是有比较大的适用范围。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;ctypes&lt;/strong&gt;: 通常用于封装(wrap)C程序，让纯Python程序调用动态链接库（Windows中的dll或Unix中的so文件）中的函数。如果想要在python中使用已经有C类库，使用ctypes是很好的选择，有一些基准测试下，python2+ctypes是性能最好的方式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Cython&lt;/strong&gt;: Cython是CPython的超集，用于简化编写C扩展的过程。Cython的优点是语法简洁，可以很好地兼容numpy等包含大量C扩展的库。Cython的使得场景一般是针对项目中某个算法或过程的优化。在&lt;a href=&#34;http://docs.cython.org/src/tutorial/numpy.html&#34;&gt;某些测试&lt;/a&gt;中，可以有几百倍的性能提升。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;cffi&lt;/strong&gt;: cffi的就是ctypes在pypy（详见下文）中的实现，同进也兼容CPython。cffi提供了在python使用C类库的方式，可以直接在python代码中编写C代码，同时支持链接到已有的C类库。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用这些优化方式一般是针对已有项目性能瓶颈模块的优化，可以在少量改动原有项目的情况下大幅度地提高整个程序的运行效率。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;并行编程&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;因为GIL的存在，Python很难充分利用多核CPU的优势。但是，可以通过内置的模块multiprocessing实现下面几种并行模式：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;多进程&lt;/strong&gt;：对于CPU密集型的程序，可以使用multiprocessing的Process,Pool等封装好的类，通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数据交互的程序效率未必有大的提高。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;多线程&lt;/strong&gt;：对于IO密集型的程序，multiprocessing.dummy模块使用multiprocessing的接口封装threading，使得多线程编程也变得非常轻松(比如可以使用Pool的map接口，简洁高效)。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;分布式&lt;/strong&gt;：multiprocessing中的Managers类提供了可以在不同进程之共享数据的方式，可以在此基础上开发出分布式的程序。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不同的业务场景可以选择其中的一种或几种的组合实现程序性能的优化。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;终级大杀器：PyPy&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;PyPy是用RPython(CPython的子集)实现的Python，根据官网的基准测试数据，它比CPython实现的Python要快6倍以上。快的原因是使用了Just-in-Time(JIT)编译器，即动态编译器，与静态编译器(如gcc,javac等)不同，它是利用程序运行的过程的数据进行优化。由于历史原因，目前pypy中还保留着GIL，不过正在进行的STM项目试图将PyPy变成没有GIL的Python。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果python程序中含有C扩展(非cffi的方式)，JIT的优化效果会大打折扣，甚至比CPython慢（比Numpy）。所以在PyPy中最好用纯Python或使用cffi扩展。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;随着STM，Numpy等项目的完善，相信PyPy将会替代CPython。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;h3&gt;使用性能分析工具&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;除了上面在ipython使用到的timeit模块，还有cProfile。cProfile的使用方式也非常简单： &lt;code&gt;python -m cProfile filename.py&lt;/code&gt;，&lt;code&gt;filename.py&lt;/code&gt; 是要运行程序的文件名，可以在标准输出中看到每一个函数被调用的次数和运行的时间，从而找到程序的性能瓶颈，然后可以有针对性地优化。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;参考&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://docs.cython.org/src/tutorial/numpy.html&#34;&gt;1&lt;/a&gt; &lt;a href=&#34;http://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/&#34;&gt;http://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[2] &lt;a href=&#34;http://maxburstein.com/blog/speeding-up-your-python-code/&#34;&gt;http://maxburstein.com/blog/speeding-up-your-python-code/&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>常见的数据结构与算法及其应用场景</title>
      <link>http://sample.com/数据结构/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>2014-02-19 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;1. 常见数据结构&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;根据wikipedia上的列表，数据结构分为线性、树、哈希、图等类型。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;线性数据结构&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;数组&lt;/p&gt;&#xA;&#xA;&lt;p&gt;位图索引：一种高效、节省空间的索引。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;链表&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;块状链表&lt;/p&gt;&#xA;&#xA;&lt;p&gt;综合了数组随机访问、遍历、存储空间方面的优点和链表插入、删除、空间扩展方面的优点。[2]&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;对应的抽象数据类型：栈，队列（单/双向、优先队列）&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;树型数据结构&lt;/h3&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;二叉树&lt;/p&gt;&#xA;&#xA;&lt;p&gt;二叉查找树：根节点的值比较左子节点大，比右子节点小。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;AVL树：是一种自平衡二叉查找树，所有节点的两棵子树高度差小于1，查找、插入和删除在平均和最坏情况下都是O（log n）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;红黑树：节点分红色和黑色，任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点，根到叶子的路径不多于最短路径的两倍长，查找、插入和删除在平均和最坏情况下都是O（log n），典型应用是关联数组。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;T树：节点的结构形状如&amp;rsquo;T&amp;rsquo;，用于内存数据库的索引，但是性能未必比得上B树。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;B树&lt;/p&gt;&#xA;&#xA;&lt;p&gt;B-树：一个节点可以拥有预先设定数量范围的子节点的二叉查找树，普遍运用在数据库和文件系统。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;B+树：是B-树的变种，指向数据的，叶子节点&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;堆&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;空间树&lt;/p&gt;&#xA;&#xA;&lt;p&gt;区间树（Interval tree）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;R树：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;KD树：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;四分树（Quadtree）&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;字典树（trie）&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;哈希数据类型&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;布隆过滤器（Bloom Filter）&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;哈希表&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;哈希树&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;图型数据结构&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;邻接矩阵&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;邻接链表&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;常用算法及思想&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查找&lt;/li&gt;&#xA;&lt;li&gt;排序算法：冒泡，插入，选择，快排，归并排序，堆排序，桶排序&lt;/li&gt;&#xA;&lt;li&gt;递归与分治：&lt;/li&gt;&#xA;&lt;li&gt;贪心：&lt;/li&gt;&#xA;&lt;li&gt;动态规划：背包问题，最长公共子序列，最优二分检索树&lt;/li&gt;&#xA;&lt;li&gt;回溯（含剪枝）：&lt;/li&gt;&#xA;&lt;li&gt;图算法：深度优先遍历与广度优先遍历， 最短路径，最小生成树，拓扑排序&lt;/li&gt;&#xA;&lt;li&gt;字符串算法：字符串查找，hash算法，KMP算法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;（待完善）&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;参考内容&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;[1] &lt;a href=&#34;http://en.wikipedia.org/wiki/List_of_data_structures&#34;&gt;http://en.wikipedia.org/wiki/List_of_data_structures&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[2] &lt;a href=&#34;http://blog.csdn.net/wypblog/article/details/8299895&#34;&gt;http://blog.csdn.net/wypblog/article/details/8299895&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[3] &lt;a href=&#34;http://blog.chinaunix.net/uid-28698407-id-3870369.html&#34;&gt;http://blog.chinaunix.net/uid-28698407-id-3870369.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[4] &lt;a href=&#34;http://dongxicheng.org/structure/structure-algorithm-summary/&#34;&gt;http://dongxicheng.org/structure/structure-algorithm-summary/&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Git使用帮助</title>
      <link>http://sample.com/编程工具/Git%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/</link>
      <pubDate>2013-10-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;strong&gt;Git&lt;/strong&gt;是一个分布式的版本管理软件。相比于SVN，Git分布式的模式使得它对网络的依赖性较低， 只有在同步最新版本(fetch/push)时才需要连接网络，同时Git具有更高效的存储方式。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Ubuntu可用apt-get安装：&lt;code&gt;apt-get install git&lt;/code&gt;。或通过&lt;a href=&#34;http://git-scm.com/download&#34;&gt;源码安装&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;配置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用&lt;code&gt;git config&lt;/code&gt;进行配置，安装后最好设定自己的用户名和邮箱，也可以给git命令设置别名。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git config --global user.name myname # 要改成你的用户名&#xA;git config --global user.email myemail@mail.com # 改成你的邮箱名&#xA;git config --global core.editor vim&#xA;git config --global alias.co checkout&#xA;git config --global alias.br branch&#xA;git config --global alias.ci commit&#xA;git config --global alias.st status&#xA;git config --global --list&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2&gt;使用&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;下载版本库代码&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;使用&lt;code&gt;git clone&lt;/code&gt;（类似于svn checkout），下面的例子中需要输入密码(测试账号密码为gitpass)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd &#xA;git clone git@42.121.109.199:/git/project.git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;查看文件状态&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Git下文件有三种状态：已修改（modified）和已暂存（staged），已提交（committed），如要修改一个文件，编辑保存后文件的状态为modified，运行 &lt;code&gt;git add [newfile]&lt;/code&gt; 后状态变为staged，然后运行&lt;code&gt;git commit&lt;/code&gt;将变化提交到版本库，状态变为committed。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用&lt;code&gt;git status&lt;/code&gt;可查看文件状态:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd project&#xA;git status&#xA;echo &#39;I name all my projects after myself. First Linux, now git.&#39; &amp;gt;&amp;gt; newfile&#xA;git status&#xA;git add newfile &#xA;git status&#xA;git commit -m &#39;Just have fun!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;将修改的文件添加到暂存(staged)文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;git add [arg]&lt;/code&gt;，arg可以文件或目录名，如果是目录会将目录下所有文件添加到staged状态。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;查看文件内容变化&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt;会显示modified状态下的所有文件内容与上次提交后的变化，&lt;code&gt;git diff --cached&lt;/code&gt;会显示staged状态下文件内容与上次提交的变化。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;echo &#39;Linus is Git ?&#39; &amp;gt;&amp;gt; newfile&#xA;git diff # 若此时运行git diff --cached，没有显示文件内容的变化&#xA;git add newfile&#xA;git diff --cached&#xA;git commit -m &#39;show diff&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;分支的添加与合并&lt;/p&gt;&#xA;&#xA;&lt;p&gt;git中分支与svn不同，git可以通过单个命令就可以切换分支且无需复制代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt;显示所有分支，带&lt;code&gt;*&lt;/code&gt;的分支为当前的分支，&lt;code&gt;git branch [branch-name]&lt;/code&gt;添加分支，&lt;code&gt;git checkout [branch-name]&lt;/code&gt;切换分支， &lt;code&gt;git merge [branch-name]&lt;/code&gt;将另一个分支合并到当前分支,&lt;code&gt;git branch -d [branch-name]&lt;/code&gt;删除分支。合并分支可能会产生冲突，编辑有冲突的文件后用&lt;code&gt;git add&lt;/code&gt;解决冲突，然后才可以commit代码。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git branch&#xA;git branch mybranch&#xA;git checkout mybranch&#xA;echo &#39;Yes&#39; &amp;gt;&amp;gt; newfile&#xA;git add newfile&#xA;git commit -m &#39;mybranch come&#39;&#xA;&#xA;git checkout master&#xA;git merge mybranch&#xA;git branch -d mybranch&#xA;git commit -m &#39;merge mybranch&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;提交到远程版本库&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;git remote -v&lt;/code&gt;可以看到远程版本库的信息，&lt;code&gt;git push [remote-name] [branch-name]&lt;/code&gt;将当前分支的内容提交到远程服务器(remote-name)的branch-name分支。如果在push前，已经有其他人push过，则需要把他们的更新&lt;code&gt;git fetch [remote-name]&lt;/code&gt;到本地，merge到自己的branch中，然后才可以再次push。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git push origin master&#xA;git fetch origin master&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;git fetch&lt;/code&gt;只是将版本库信息更新下来，即使同一个版本也要合并&lt;code&gt;git merge [branch-name]&lt;/code&gt;才会见到更新，或者用&lt;code&gt;git pull [remote-name] [branch-name]&lt;/code&gt;，这个相当于同时执行fetch和merge命令。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;显示提交的记录&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;git log&lt;/code&gt;即可，通过参数可以定制显示的格式，详情&lt;code&gt;git log --help&lt;/code&gt;(其他命令加--help都可以看到对应的用法)。&lt;code&gt;gitk&lt;/code&gt;是集成到git中显示历史提交记录的工具，图形化的界面一目了然。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Git的详细使用可以看&lt;a href=&#34;https://github.com/progit/progit&#34;&gt;progit&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;搭建Git服务器（SSH方式）&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;创建一个普通用户(尽量不要用root用户)。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;在一个有读写权限的目录新建一个目录，进入目录后创建祼仓库，至此Git服务器创建完成。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo adduser git&#xA;su git&#xA;mkdir ~/proj.git&#xA;cd ~/proj.git&#xA;git init --bare&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;在某一个机器上使用该仓库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git@192.168.1.124:~/proj.git #第2个git为之前创建的用户名，ip为git服务器的ip，后面是git仓库的目录。&#xA;cd proj&#xA;touch test_git&#xA;git add .&#xA;git commit -m &#39;Just a test&#39;&#xA;git push origin master #将修改提交到Git服务器&#xA;gitk&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;参考&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://zh.wikipedia.org/wiki/Git&#34;&gt;http://zh.wikipedia.org/wiki/Git&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.aqee.net/5-fundamental-differences-between-git-svn/&#34;&gt;http://www.aqee.net/5-fundamental-differences-between-git-svn/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/progit/progit/blob/master/zh/&#34;&gt;https://github.com/progit/progit/blob/master/zh/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
  </channel>
</rss>